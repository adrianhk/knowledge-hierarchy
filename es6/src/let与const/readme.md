
## let

- 基本用法

ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let声明所在的代码块内有效。

e.g 1.1
```
{
    var a = 1;
    let b = 10;
}
console.log(a);
console.log(b);
```
例子中，我们分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。


- 不存在变量提升

let不像var那样会发生“变量提升”现象。
所以，变量一定要在声明后使用，否则报错。

e.g 1.2
```
console.log(a);
console.log(b);

var a = 2;
let b = 1;
```
代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。


e.g 1.3
```
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function() {
        console.log(i);
    }
}
console.log(a[6]());
```
上面代码中，变量i是var声明的，不仅在块级作用域里有效，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。

- 不允许重复声明

let不允许在相同作用域内，重复声明同一个变量。
```
function f(arg) {
    let arg; 
}
```
因此，不能在函数内部重新声明参数。

- 块级作用域

ES5只有全局作用域和函数作用域，没有块级作用域。这带来很多不合理的场景。

e.g 1.5
```
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = "hello world";
  }
}

f();
```
用var声明变量temp，会得到“undefined”，因为在if内声明tmp会被提升到函数头部覆盖了外层变量，这样在日常开发中往往会带来不必要的麻烦。
改为let使局部变量temp拥有块级作用域，这样就对作用域之外没有影响

ES5没有块级作用域的弊端：

1.内层变量可能会覆盖外层变量

2.用来计数的循环变量泄露为全局变量

某种意义上来说ES6 let实际上为JavaScript新增了块级作用域。



## const

- 基本用法

const声明一个只读的常量。一旦声明，常量的值就不能改变。

e.g 2.1
```
const P = 3.1415;
P = 3;
```
上面代码表明改变常量的值会报错。

e.g 2.1
```
const P
```
const声明的变量不得改变值，这意味着:
const一旦声明变量，就必须立即初始化，不能留到以后赋值。


- const的作用域与let命令相同

1.只在声明所在的块级作用域内有效

2.声明的常量也是不提升

3.不可重复声明